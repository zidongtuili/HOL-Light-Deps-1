(* ========================================================================= *)
(* Useful OCaml functions.                                                   *)
(*                                                                           *)
(*                            Petros Papapanagiotou                          *)
(*              Center of Intelligent Systems and their Applications         *)
(*                           University of Edinburgh                         *)
(*                                 2010-2015                                 *)
(* ========================================================================= *)

needs "IsabelleLight/support.ml";; (* for print_varandtype *)


(* ------------------------------------------------------------------------- *)
(* Remove all elements of list r from list l ONCE.                           *)
(* ------------------------------------------------------------------------- *)

let rec remove_list l r =
  match r with
    | [] -> l
    | h::t ->
      let res = try (snd (remove (fun x -> x = h) l)) with Failure _ -> l in
      remove_list res t;;

(* ------------------------------------------------------------------------- *)
(* Partitions a list by filtering through each element of another list using *)
(* function f. Each element is removed once.                                 *)
(* ------------------------------------------------------------------------- *)

let partition_list f l t =
  let pick x l,r =
    let i,rest = remove (f x) r in
    i::l,rest in
  itlist pick l ([],t);;

(* ------------------------------------------------------------------------- *)
(* Topological sort for a dependency tree.                                   *)
(* Perhaps not the most efficient, but it will do.                           *)
(* ------------------------------------------------------------------------- *)

let rec dependency_sort isParentOf l =
  match l with 
    | [] -> []
    | (h::t) -> 
	let deps,nodeps = partition (isParentOf h) t in
	(dependency_sort isParentOf deps) @ [h] @ (dependency_sort isParentOf nodeps);;

(* ------------------------------------------------------------------------- *)
(* Apply a function to both members of a pair. Same as 'f ## f' in HOL4.     *)
(* ------------------------------------------------------------------------- *)

let hashf f (x,y) = (f x, f y) ;;

(* ------------------------------------------------------------------------- *)
(* Invert pairs.                                                             *)
(* Used to invert substitutions.                                             *)
(* ------------------------------------------------------------------------- *)

let invpair (x,y) = y,x;;

let invpairs l = map invpair l;;

(* ------------------------------------------------------------------------- *)
(* Function used for indented prints.                                        *)
(* ------------------------------------------------------------------------- *)

let rec print_depth depth prn arg =
  match depth with
      0 -> (prn arg ; print_newline ())
    | _ -> (print_string " " ; print_depth (depth -1) prn arg);;


(* ------------------------------------------------------------------------- *)
(* print_goalstack_all :                                                     *) 
(* Alternative goalstack printer that always prints all subgoals.            *)
(* Also prints list of metavariables with their types.                       *)
(* ------------------------------------------------------------------------- *)
(* Original printer only prints more than one subgoals iff they were         *)
(* generated by the last step. Otherwise it only prints the 'active' subgoal.*)
(* Replace by #install_printer print_goalstack_all;;                         *)
(* Revert to original by #install_printer print_goalstack;;                  *)
(* ------------------------------------------------------------------------- *)

let (print_goalstack_all:goalstack->unit) =
  let print_goalstate k gs =
    let ((mvs,_),gl,_) = gs in
    let n = length gl in
    let s = if n = 0 then "No subgoals" else
              (string_of_int k)^" subgoal"^(if k > 1 then "s" else "")
           ^" ("^(string_of_int n)^" total)" in
    let print_mv v = print_string " `" ; print_varandtype std_formatter v ; print_string "`;" in
    print_string s; print_newline();
    if (length mvs > 0) then (
      print_string "Metas:" ; let _ = map print_mv mvs in () ; print_newline()
    ) ; 
    if gl = [] then () else
    do_list (print_goal o C el gl) (rev(0--(k-1))) in
  fun l ->
    if l = [] then print_string "Empty goalstack"
    else 
      let a,gl,b,_ = hd l in
      print_goalstate (length gl) (a,gl,b);;


(* ------------------------------------------------------------------------- *)
(* print_thl:                                                                *)
(* Print a list of theorems (for debugging).                                 *)
(* ------------------------------------------------------------------------- *)

let print_thl thl = 
  map (fun thm -> ( print_thm thm ; print_newline ())) thl;;


(* ------------------------------------------------------------------------- *)
(* print_tml:                                                                *)
(* Print a list of terms (for debugging).                                    *)
(* ------------------------------------------------------------------------- *)

let print_tml tml = 
    map (fun tm -> ( print_term tm ; print_newline ())) tml;;


(* ------------------------------------------------------------------------- *)
(* count_goals : unit -> int                                                 *) 
(* Shortcut to count the subgoals in the current goalstate.                  *)
(* ------------------------------------------------------------------------- *)

let count_goals () =
  if (!current_goalstack = []) then 0 else
  (length o snd3 o (fun a,b,c,_ -> a,b,c) o hd) !current_goalstack;;


(* ------------------------------------------------------------------------- *)
(* top_asms : goalstack -> (string * thm) list                               *) 
(* Shortcut to get the assumption list of the top goal of a given goalstack. *)
(* ------------------------------------------------------------------------- *)

let top_asms (gs:goalstack) = (fst o hd o snd3 o (fun a,b,c,_ -> a,b,c) o hd) gs;;


(* ------------------------------------------------------------------------- *)
(* top_metas : goalstack -> term list                                        *) 
(* Returns the list of metavariables in the current goalstate.               *)
(* ------------------------------------------------------------------------- *)
(* This also exists in Isabelle Light.                                       *)
(* ------------------------------------------------------------------------- *)

let top_metas (gs:goalstack) = (fst o fst3 o (fun a,b,c,_-> a,b,c)  o hd) gs;;


(* ------------------------------------------------------------------------- *)
(* top_inst : goalstack -> instantiation                                     *) 
(* Returns the metavariable instantiations in the current goalstate.         *)
(* ------------------------------------------------------------------------- *)

let top_inst (gs:goalstack) = (snd o fst3 o (fun a,b,c,_ -> a,b,c) o hd) gs;;


(* ------------------------------------------------------------------------- *)
(* e_all : tactic -> goalstack                                               *) 
(* Same as "e" but applies tactic to ALL subgoals.                           *)
(* ------------------------------------------------------------------------- *)
(* This could be done better by implementing a by_all function, but it'll    *)
(* do for now since it's rarely used anyway.                                 *) 
(* ------------------------------------------------------------------------- *)

let e_all tac =
  let c = (count_goals()) in
  let rec f i = ( 
    if (i = 0) 
    then (!current_goalstack) 
    else let _ = e tac in let _ = r 1 in f (i-1) 
   ) in f c;;


(* ------------------------------------------------------------------------- *)
(* refine for any goalstate.                                                 *)
(* ------------------------------------------------------------------------- *)

let (refinestack:refinement->goalstack->goalstack) =
  fun r gs ->
    if gs = [] then failwith "No current goal" else
    let h = hd gs in
    r h :: gs;;

(* ------------------------------------------------------------------------- *)
(* e for any goalstate.                                                      *)
(* ------------------------------------------------------------------------- *)

let (apply_tac:tactic->goalstack->goalstack) =
  fun tac gs -> refinestack (by(VALID tac)) gs;;


(* ------------------------------------------------------------------------- *)
(* top_thm for any goalstate.                                                *)
(* ------------------------------------------------------------------------- *)

let get_thm (gs:goalstack) =
  let (_,[],f,_)::_ = gs in
  f null_inst [] ;;


